using System;

namespace Sempiler.AST
{
    /*
        We opt for conceptual (ArithmeticAdd, Assignment) rather than lexical kinds (AsteriskToken, PlusToken)
        because we are in the business of semantics not syntax.. and if we use a certain token in the source language
        the target emitter may misinterpret that symbol if it means something else in the target context. - 19/07/18
     */
    public enum SemanticKind
    {
        AccessorDeclaration,
        AccessorSignature,
        Addition,
        AdditionAssignment,
        AddressOf,
        Annotation,
        ArithmeticNegation,
        ArrayConstruction,
        ArrayTypeReference,
        ArtifactReference,
        Assignment,
        Association,
        BitwiseAnd,
        BitwiseAndAssignment,
        BitwiseExclusiveOr,
        BitwiseExclusiveOrAssignment,
        BitwiseLeftShift,
        BitwiseLeftShiftAssignment,
        BitwiseNegation,
        BitwiseOr,
        BitwiseOrAssignment,
        BitwiseRightShift,
        BitwiseRightShiftAssignment,
        BitwiseUnsignedRightShift,
        BitwiseUnsignedRightShiftAssignment,
        Block,
        BooleanConstant,
        Breakpoint,
        BridgeFunctionDeclaration,
        BridgeInvocation,
        ClauseBreak,
        CodeConstant,
        ComputedValue,
        CollectionDestructuring,
        CompilerHint,
        Component,
        Concatenation,
        ConcatenationAssignment,
        ConditionalTypeReference,
        LiteralTypeReference,
        ConstructorDeclaration,
        ConstructorSignature,
        ConstructorTypeReference,
        DataValueDeclaration,
        DefaultExportReference,
        Destruction,
        DestructorDeclaration,
        DestructorSignature,
        DestructuredMember,
        DictionaryConstruction,
        DictionaryTypeReference,
        Directive,
        Division,
        DivisionAssignment,
        DoOrDieErrorTrap,
        DoOrRecoverErrorTrap,
        DoWhilePredicateLoop,
        Domain,
        DynamicTypeConstruction,
        DynamicTypeReference,
        EntityDestructuring,
        EnumerationMemberDeclaration,
        EnumerationTypeDeclaration,
        ErrorFinallyClause,
        ErrorHandlerClause,
        ErrorTrapJunction,
        EvalToVoid,
        Exponentiation,
        ExponentiationAssignment,        
        ExportDeclaration,
        FieldDeclaration,
        FieldSignature,
        ForKeysLoop,
        ForMembersLoop,
        ForPredicateLoop,
        ForcedCast,
        FunctionDeclaration,
        FunctionTermination,
        FunctionTypeReference,
        GeneratorSuspension,
        GlobalDeclaration,
        Identifier,
        Identity,
        ImportDeclaration,
        IncidentContextReference,
        IncidentTypeConstraint,
        IndexTypeQuery,
        InferredTypeQuery,
        IndexedAccess,
        IndexerSignature,
        InterfaceDeclaration,
        InterimSuspension,
        InterpolatedString,
        InterpolatedStringConstant,
        IntersectionTypeReference,
        IntrinsicTypeReference,
        Invocation,
        InvocationArgument,
        JumpToNextIteration,
        KeyValuePair,
        Label,
        LambdaDeclaration,
        LogicalAnd,
        LogicalNegation,
        LogicalOr,
        LoopBreak,
        LooseEquivalent,
        LooseNonEquivalent,
        LowerBoundedTypeConstraint,
        MappedDestructuring,
        MappedTypeReference,
        MatchClause,
        MatchJunction,
        MaybeNull,
        MemberNameReflection,
        MemberTypeConstraint,
        MembershipTest,
        Meta,
        MetaProperty,
        MethodDeclaration,
        MethodSignature,
        Modifier,
        Multiplication,
        MultiplicationAssignment,
        MutatorDeclaration,
        MutatorSignature,
        Mutex,
        NamedTypeConstruction,
        NamedTypeQuery,
        NamedTypeReference,
        NamespaceDeclaration,
        NamespaceReference,
        NonMembershipTest,
        Nop,
        NotNull,
        NotNumber,
        Null,
        NullCoalescence,
        NumericConstant,
        ObjectTypeDeclaration,
        ParameterDeclaration,
        ParenthesizedTypeReference,
        PointerDereference,
        PointerTypeReference,
        PostDecrement,
        PostIncrement,
        PreDecrement,
        PreIncrement,
        PredicateFlat,
        PredicateJunction,
        PrioritySymbolResolutionContext,
        PropertyDeclaration,
        QualifiedAccess,
        RaiseError,
        ReferenceAliasDeclaration,
        RegularExpressionConstant,
        Remainder,
        RemainderAssignment,
        SafeCast,
        SmartCast,
        SpreadDestructuring,
        StrictEquivalent,
        StrictGreaterThan,
        StrictGreaterThanOrEquivalent,
        StrictLessThan,
        StrictLessThanOrEquivalent,
        StrictNonEquivalent,
        StringConstant,
        Subtraction,
        SubtractionAssignment,
        SuperContextReference,
        TupleConstruction,
        TupleTypeReference,
        TypeAliasDeclaration,
        TypeInterrogation,
        TypeParameterDeclaration,
        TypeQuery,
        TypeTest,
        UpperBoundedTypeConstraint,
        UnionTypeReference,
        ViewConstruction,
        ViewDeclaration,
        WhilePredicateLoop,
        WildcardExportReference
    }


    // eg. could have an Identifier that plays the SemanticRole of a function name
    public enum SemanticRole
    {
        // wht about function? class?
        None, // ??
        Component,
        Base,
        
        Body,
        Content,
        Scope,
        From,
        Specifier,
        Clause,
        Constraint,
        Default,
        Initializer,
        Accessor,
        Mutator,
        Condition,
        Pattern,
        Iterator,
        Handle,
        Incident,
        Exponent,
        Annotation,
        Modifier,
        Argument,
        Label,
        Key,
        KeyType,
        StoredType,
        Value,
        Literal,
        Storage,
        Meta,
        Member,
        Name,
        ParserName,
        Operand,
        Criteria,
        Parameter,
        TypeParameter, 
        Parent,
        Predicate,
        TrueBranch,
        FalseBranch,
        Super,
        Interface,
        Size,
        Subject, // [dho] to be deleted/refactored? - 11/05/19
        // Future,
        Offset,
        Template,
        // To,
        TargetType,
        TrueType,
        TrueValue,
        FalseType,
        FalseValue,
        Type,
        SymbolProvider,
        Flag,
        Property,
        Child, 
        ViewPreview,
    }
}