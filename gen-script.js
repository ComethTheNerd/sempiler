const template = (name) => `
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ${name} ${name}(RawAST ast, Node node)
        {
            return new ${name}(ast, node);
        }
`;

const names = `
AccessorDeclaration,
        AccessorSignature,
        Addition,
        AdditionAssignment,
        AddressOf,
        Annotation,
        ArithmeticNegation,
        ArrayConstruction,
        ArrayTypeReference,
        Assignment,
        Association,
        BitwiseAnd,
        BitwiseAndAssignment,
        BitwiseExclusiveOr,
        BitwiseExclusiveOrAssignment,
        BitwiseLeftShift,
        BitwiseLeftShiftAssignment,
        BitwiseNegation,
        BitwiseOr,
        BitwiseOrAssignment,
        BitwiseRightShift,
        BitwiseRightShiftAssignment,
        BitwiseUnsignedRightShift,
        BitwiseUnsignedRightShiftAssignment,
        Block,
        BooleanConstant,
        Breakpoint,
        ClauseBreak,
        CodeConstant,
        CollectionDestructuring,
        CompilerHint,
        Component,
        Concatenation,
        ConcatenationAssignment,
        ConditionalTypeReference,
        LiteralTypeReference,
        ConstructorDeclaration,
        ConstructorSignature,
        ConstructorTypeReference,
        DataValueDeclaration,
        DefaultExportReference,
        Destruction,
        DestructorDeclaration,
        DestructorSignature,
        DestructuredMember,
        DictionaryConstruction,
        DictionaryTypeReference,
        Division,
        DivisionAssignment,
        DoOrDieErrorTrap,
        DoOrRecoverErrorTrap,
        DoWhilePredicateLoop,
        Domain,
        DynamicTypeConstruction,
        DynamicTypeReference,
        EntityDestructuring,
        EnumerationMemberDeclaration,
        EnumerationTypeDeclaration,
        ErrorFinallyClause,
        ErrorHandlerClause,
        ErrorTrapJunction,
        EvalToVoid,
        Exponentiation,
        ExponentiationAssignment,        
        ExportDeclaration,
        FieldDeclaration,
        FieldSignature,
        ForKeysLoop,
        ForMembersLoop,
        ForPredicateLoop,
        ForcedCast,
        FunctionDeclaration,
        FunctionTermination,
        FunctionTypeReference,
        GeneratorSuspension,
        GlobalDeclaration,
        Identifier,
        Identity,
        IfDirective,
        ImportDeclaration,
        IncidentContextReference,
        IncidentTypeConstraint,
        IndexTypeQuery,
        InferredTypeQuery,
        IndexedAccess,
        IndexerSignature,
        InterfaceDeclaration,
        InterimSuspension,
        InterpolatedString,
        InterpolatedStringConstant,
        IntersectionTypeReference,
        IntrinsicTypeReference,
        Invocation,
        InvocationArgument,
        JumpToNextIteration,
        KeyValuePair,
        Label,
        LambdaDeclaration,
        LogicalAnd,
        LogicalNegation,
        LogicalOr,
        LoopBreak,
        LooseEquivalent,
        LooseNonEquivalent,
        LowerBoundedTypeConstraint,
        MappedDestructuring,
        MappedTypeReference,
        MatchClause,
        MatchJunction,
        MaybeNull,
        MemberNameReflection,
        MemberTypeConstraint,
        MembershipTest,
        Meta,
        MetaProperty,
        MethodDeclaration,
        MethodSignature,
        Modifier,
        Multiplication,
        MultiplicationAssignment,
        MutatorDeclaration,
        MutatorSignature,
        Mutex,
        NamedTypeConstruction,
        NamedTypeQuery,
        NamedTypeReference,
        NamespaceDeclaration,
        NamespaceReference,
        NonMembershipTest,
        Nop,
        NotNull,
        NotNumber,
        Null,
        NullCoalescence,
        NumericConstant,
        ObjectTypeDeclaration,
        OrderedGroup,
        ParameterDeclaration,
        ParenthesizedTypeReference,
        PointerDereference,
        PointerTypeReference,
        PostDecrement,
        PostIncrement,
        PreDecrement,
        PreIncrement,
        PredicateFlat,
        PredicateJunction,
        PrioritySymbolResolutionContext,
        PropertyDeclaration,
        QualifiedAccess,
        RaiseError,
        ReferenceAliasDeclaration,
        RegularExpressionConstant,
        Remainder,
        RemainderAssignment,
        RunDirective,
        SafeCast,
        SmartCast,
        SpreadDestructuring,
        StrictEquivalent,
        StrictGreaterThan,
        StrictGreaterThanOrEquivalent,
        StrictLessThan,
        StrictLessThanOrEquivalent,
        StrictNonEquivalent,
        StringConstant,
        Subtraction,
        SubtractionAssignment,
        SuperContextReference,
        TupleConstruction,
        TupleTypeReference,
        TypeAliasDeclaration,
        TypeInterrogation,
        TypeParameterDeclaration,
        TypeQuery,
        TypeTest,
        UpperBoundedTypeConstraint,
        UnionTypeReference,
        WhilePredicateLoop,
        WildcardExportReference
`


const output = names.split(',').map(x => x.trim()).map(template).join("\n");

console.log(output);